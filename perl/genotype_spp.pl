#!/usr/bin/env perl

=head1 NAME

  genotype_spp.pl

=head1 DESCRIPTION

  Given a vicut directory with an updated taxon table, updated.tx, generated by
  update_tx_tree.pl, and a cluster table file. For each species identify clusters
  where it is found and the number of sequences in each cluster.

  Species present in more than one cluster are renamed by adding a suffix
  'tRT_i', where i=1,2,3 .. and tRT is a shorthand for 'tentative ribotype'

  Here are a few examples (see spp_freq.summary in vicut_dir)

  Lactobacillus_paralimentarius
  116	9
  55	1

  Lactobacillus_buchneri
  142	14
  35	1

  Lactobacillus_similis
  146	4
  123	2

  Lactobacillus_johnsonii
  88	25
  84	2
  86	2
  76	1

  Lactobacillus_letivazi
  60	1
  56	1

  The first number is cluster ID and the second the number of sequences of the
  given species present in that cluster.

  spp_outliers.pl treated sequences from clusters with less than 3 elements as
  outliers and vicut was run on them to reclassify them. Here we apply a
  different philosophy treating even small clusters as potential true ribotype
  forms of the given species. Thus the cluster of Lactobacillus_johnsonii will be
  labeled Lactobacillus_johnsonii_1, Lactobacillus_johnsonii_2,
  Lactobacillus_johnsonii_3, Lactobacillus_johnsonii_4.


  What to do with _sp only clusters ???

  STRATEGY 1. Create Genus_sp_i taxonomy for each vicut cluster of Genus_sp
  species (use the majority vote if different _sp species end up in the same
  cluster).

  STRATEGY 2. Keep _sp taxonomy as before vicut.


  The script generates the following files

  spp_freq.summary - with species present in more than one cluster, together with
  cluster ID and the number of the given sequences in that cluster.

  outlier.seqIDs - one column table sequence IDs identified as outliers.
                   I include sequence IDs of c-clusters as well.

  clstr_tbl.txt - three column table for species present in more than one cluster

  ann.tx - two column table of seqIDs and species name for all sequences
           that are not outliers and also are not present in <genus>_sp species.

  query.ids - one column table with sequence IDs of non-outlier sequences from <genus>_sp
              species.

  <txFile>_noOutliers.tx - taxonomy file used in the script as input with outliers sequences removed from it.


=head1 SYNOPSIS

  genotype_spp.pl -o <vicut dir> [Options]

=head1 OPTIONS

=over

=item B<--vicut-dir, -d>
  vicut output directory, that will be used also as an output directory. It is
  assumed that it contains an updated.tx file that was generated by
  update_tx_tree.pl.

=item B<--dry-run>
  Print commands to be executed, but do not execute them.

=item B<--debug>
  Prints system commands

=item B<-h|--help>
  Print help message and exit successfully.

=back


=head1 EXAMPLE

  cd /Users/pgajer/devel/MCclassifier/data/SILVA_123/Lactobacillaceae_ss100_dir

  genotype_spp.pl -d Lactobacillaceae_vicut_full_sate_dir

=cut

use strict;
use warnings;
use Pod::Usage;
use English qw( -no_match_vars );
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev pass_through);
use File::Basename;

$OUTPUT_AUTOFLUSH = 1;

####################################################################
##                             OPTIONS
####################################################################

my $clSizeThld = 2; # sequences from clusters of this size of smaller are marked
		    # as outliers if the species is present in more than one
		    # cluster and it is not the first cluster (when ordering by
		    # size).
GetOptions(
  "vicut-dir|d=s"    => \my $vicutDir,
  "dry-run"          => \my $dryRun,
  "debug"            => \my $debug,
  "help|h!"          => \my $help,
  )
  or pod2usage(verbose => 0,exitstatus => 1);


if ($help)
{
  pod2usage(verbose => 2,exitstatus => 0);
  exit 1;
}

if (!$vicutDir)
{
  print "\n\nERROR: Missing vicut directory\n\n\n";
  pod2usage(verbose => 2,exitstatus => 0);
  exit 1;
}


####################################################################
##                               MAIN
####################################################################

## parsing updated taxon table
print "[genotype_spp.pl] --- Parsing updated taxon table" if $debug;
my $txFile = "$vicutDir/updated.tx";
my %tx = read2colTbl($txFile);

my %sppFreq; ## table of number of sequences per species
map { $sppFreq{$_}++ } values %tx;

my %sppFreq2; ## frequency table of species sequence frequencies
map { $sppFreq2{$_}++ } values %sppFreq;

## number of _sp species
my $nSpSpp = 0;
my %genus;
for (keys %sppFreq)
{
  my ($g, $s) = split "_";
  $nSpSpp++ if $s && $s eq "sp";
  push @{$genus{$g}}, $_;
}

## Number of genera with only one species and the species being _sp
my $nSpGenera = 0;
my @spGenera;
my %spSpecies;
for my $g (keys %genus)
{
  if ( scalar(@{$genus{$g}})==1 )
  {
    my $sp = $genus{$g}->[0];
    my ($g, $s) = split "_", $sp;
    if ($s && $s eq "sp")
    {
      $nSpGenera++;
      push @spGenera, $g;
      $spSpecies{$sp} = 1;
    }
  }
}

## parsing cluster table
print "\r[genotype_spp.pl] --- Parsing cluster table     " if $debug;
my $cltrFile = "$vicutDir/minNodeCut.cltrs";
my %cltr = read2colTbl($cltrFile);

## generating species within cluster frequency table
print "\r[genotype_spp.pl] --- Generating species within cluster frequency table" if $debug;

my %spp; # $spp{speciesName}{clID} holds sequence IDs of the given species that
	 # belong to cluster clID
for ( keys %tx )
{
  if (exists $cltr{$_})
  {
    push @{$spp{$tx{$_}}{$cltr{$_}}}, $_;
  }
  else
  {
    stop("ERROR: $_ does not exist in $cltrFile\n");
    exit;
  }
}

## Generating file of species present in more than one cluster
print "\r[genotype_spp.pl] --- Updating taxonomy                                 " if $debug;
my $sppFreqFile = "$vicutDir/spp_freq.summary";
my $newTxFile = "$vicutDir/updated2.tx";
##my %GTcounter; # $GTcounter{$sp} current index of _GT
my $nFinal = 0;
open FREQOUT, ">$sppFreqFile" or die "Cannot open $sppFreqFile for writing: $OS_ERROR\n";
open TXOUT, ">$newTxFile" or die "Cannot open $newTxFile for writing: $OS_ERROR\n";
for my $sp ( keys %spp )
{
  my ($g, $suffix) = split "_", $sp;
  #print "\tsp: $sp\n";

  my %spCltrs = %{$spp{$sp}};
  my $nClts = keys %spCltrs;

  if ( (($suffix && $suffix eq "sp") || (defined $spSpecies{$sp}) ) && $nClts > 1 ) ## if an _sp sequence is a singleton
  ## species and is present in > 1 cluster ...
  {
    my @cltrIDs = sort { scalar(@{$spCltrs{$b}}) <=> scalar(@{$spCltrs{$a}}) } keys %spCltrs;
	## sort the species clusters by size
    print FREQOUT "$sp\n";
    ## print the
    my $clCount = 1;
    for my $clID ( @cltrIDs ) ## for each cluster ID
    {
      print FREQOUT "\t$clID\t" . scalar(@{$spCltrs{$clID}}) . "\n"; ## print the cluster ID and size of cluster
      for my $seqID (@{$spCltrs{$clID}}) ## for each seqID within that cluster ID
      {
	print TXOUT "$seqID\t$sp" . "_$clCount\n"; ## print the species and attach the cluster count to it
	$nFinal++; ## increase the final count by one
	#print "after first if statement, nfinal = $nFinal.\n\n"
      }
      $clCount++; ## and increase the cluster count by 1... repeat this for each of the cluster IDs for this species
    }
    print FREQOUT "\n";
  }
  elsif ( $suffix && $suffix eq "sp" && !defined $spSpecies{$sp} && $nClts > 1 ) ## or if something is an _sp species,
  ## and it is not a singleton _sp species (only species in genus), and it is present in > 1 cluster
  {
    # Count the number of clusters with more than $clSizeThld elements
    my $nLargeCltrs = 0;
    for my $clID (keys %spCltrs) ## for each cluster ID
    {
      $nLargeCltrs++ if (scalar(@{$spCltrs{$clID}}) > $clSizeThld); ## increase the nLargeclstr by one if  #species in
      ## the cluster are > than the threshold
    }

    if ($nLargeCltrs > 1) ## and if this # is greater than 1
    {
      my $clCount = 1; ## start the cluster count at 1
      for my $clID (keys %spCltrs) ## and for each cluster ID
      {
	if (scalar(@{$spCltrs{$clID}}) > 1) ## the # clusters for that species is > 1
	{
	  for my $seqID (@{$spCltrs{$clID}}) ## for each species, attach a cluster ID
	  {
	    print TXOUT "$seqID\t$sp" . "_$clCount\n";
	    $nFinal++;
	  }
	  $clCount++;
	}
      }
    }
    else
    {
      for my $clID (keys %spCltrs) ## otherwise, for all species clusters,
      {
		if (scalar(@{$spCltrs{$clID}}) > $clSizeThld) ## if the number of species is greater than the thld,
		{
	  		for my $seqID (@{$spCltrs{$clID}})
	  		{
	   		 print TXOUT "$seqID\t$sp\n"; ## print to taxonomy.
	   		 $nFinal++;
	  		}
		}
       }
     }
  }
  elsif ( $suffix && $suffix ne "sp" && $nClts > 1)
  {
   my @cltrIDs = sort { scalar(@{$spCltrs{$b}}) <=> scalar(@{$spCltrs{$a}}) } keys %spCltrs;
	## sort the species clusters by size
    print FREQOUT "$sp\n";
    ## print the
    my $clCount = 1;
    for my $clID ( @cltrIDs ) ## for each cluster ID
    {
      print FREQOUT "\t$clID\t" . scalar(@{$spCltrs{$clID}}) . "\n"; ## print the cluster ID and size of cluster
      for my $seqID (@{$spCltrs{$clID}}) ## for each seqID within that cluster ID
      {
	print TXOUT "$seqID\t$sp" . "_$clCount\n"; ## print the species and attach the cluster count to it
	$nFinal++; ## increase the final count by one
	print "after first if statement, nfinal = $nFinal.\n\n"
      }
      $clCount++; ## and increase the cluster count by 1... repeat this for each of the cluster IDs for this species
    }
    print FREQOUT "\n";
    }
  else ##( $suffix && $suffix eq "sp" && !defined $spSpecies{$sp} ) ## or if it is an _sp species
  {
    ##print "sp: $sp\n";
    my @clIDs = keys %spCltrs;
    ##print "clIDs: @clIDs\n";
    my $clID = shift @clIDs;

   # if (scalar(@{$spCltrs{$clID}}) > $clSizeThld)
   # {
      for my $clID (keys %spCltrs)
      {
	for my $seqID (@{$spCltrs{$clID}})
	{
	  print TXOUT "$seqID\t$sp\n";
	  $nFinal++;
	}
    #  }
    }
  }
 # else
  #{
   # ##print "sp: $sp\n";
   # my @clIDs = keys %spCltrs;
    ##print "clIDs: @clIDs\n";
   # my $clID = shift @clIDs;
   # for my $clID (keys %spCltrs)
   # {
   #   for my $seqID (@{$spCltrs{$clID}})
   #   {
#	print TXOUT "$seqID\t$sp\n";
#	$nFinal++;
#      }
#    }
#  }
}
close FREQOUT;
close TXOUT;

#my @Diff = diff( \@tx, \@newTxFile );

if ($debug)
{
  print "\r                                                            ";
  print "\n\tNumber of input sequences: " . scalar(keys %tx) . "\n";
  print   "\tNumber of sequences in the final taxonomy file: $nFinal\n\n";
}

####################################################################
##                               SUBS
####################################################################

# read two column table; create a table that assigns
# elements of the first column to the second column
sub read2colTbl{

  my $file = shift;

  if ( ! -f $file )
  {
    print "\n\nERROR: $file does not exist\n\n\n";
    exit 1;
  }

  my %tbl;
  open IN, "$file" or die "Cannot open $file for reading: $OS_ERROR\n";
  foreach (<IN>)
  {
    chomp;
    my ($id, $t) = split /\s+/,$_;
    $tbl{$id} = $t;
  }
  close IN;

  return %tbl;
}

sub diff{

  my ($a1, $a2) = @_;

  my (%aa1, %aa2);

  foreach my $e (@{$a1}){ $aa1{$e} = 1; }
  foreach my $e (@{$a2}){ $aa2{$e} = 1; }

  my @d; # dfference array

  foreach my $e (keys %aa1, keys %aa2)
  {
    push @d, $e if exists $aa1{$e} && !exists $aa2{$e};
  }

  return @d;
}

exit 0;
